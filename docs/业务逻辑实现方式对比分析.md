# 业务逻辑实现方式对比分析：SQL vs Java代码

## 一、两种方案对比

### 方案A：在SQL中实现业务逻辑（当前方案）

**实现方式：**
```xml
<!-- StSemesterBudgetMapper.xml -->
<choose>
    <when test='"1".equals(functionCategory) or "2".equals(functionCategory)'>
        <!-- 小学或初中：查询小学和初中的预算（义教阶段） -->
        and (q.function_category IN ('1', '2') or q.function_category is null or q.function_category = '')
    </when>
    <otherwise>
        and (q.function_category = #{functionCategory} or q.function_category is null or q.function_category = '')
    </otherwise>
</choose>
```

#### ✅ 优点：
1. **性能优势**：数据库层面过滤，只返回需要的数据，减少网络传输和内存占用
2. **索引优化**：数据库可以利用索引优化查询，查询速度快
3. **数据量控制**：在大数据量场景下，避免将不必要的数据加载到内存

#### ❌ 缺点：
1. **业务逻辑分散**：业务规则隐藏在SQL中，不利于理解和维护
2. **难以测试**：无法直接对SQL中的业务逻辑进行单元测试
3. **数据库绑定**：与数据库类型绑定，移植性差
4. **调试困难**：SQL中的复杂逻辑难以调试，错误排查困难
5. **代码复用性差**：业务规则无法在其他地方复用
6. **版本控制不友好**：SQL变更的diff不够清晰
7. **业务变更成本高**：如果规则变更（如新增"幼儿园"也可以组合），需要修改SQL

---

### 方案B：在Java代码中实现业务逻辑（推荐方案）

**实现方式：**
```java
// BudgetQueryService.java
public List<BudgetVO> getAvailableBudgets(Long currentSemesterId, 
                                          String economyCategory, 
                                          String functionCategory) {
    // 1. 确定需要查询的功能分类列表
    List<String> targetFunctionCategories = determineTargetFunctionCategories(functionCategory);
    
    // 2. 调用Mapper查询（传递列表参数）
    List<StSemesterBudget> budgets = semesterBudgetMapper.selectAvailableBudgets(
        currentSemesterId, economyCategory, targetFunctionCategories);
    
    return toVOList(budgets, false);
}

/**
 * 确定目标功能分类列表（业务逻辑）
 * 规则：小学（1）和初中（2）可以互相看到对方的预算
 */
private List<String> determineTargetFunctionCategories(String functionCategory) {
    if (functionCategory == null || functionCategory.isEmpty()) {
        return Collections.emptyList();
    }
    
    // 业务规则：义教阶段预算组合
    if ("1".equals(functionCategory) || "2".equals(functionCategory)) {
        return Arrays.asList("1", "2"); // 小学和初中
    }
    
    // 其他情况：只查询匹配的功能分类
    return Collections.singletonList(functionCategory);
}
```

```xml
<!-- StSemesterBudgetMapper.xml -->
<select id="selectAvailableBudgets" resultMap="StSemesterBudgetResult">
    <include refid="selectStSemesterBudgetVo"/>
    <where>
        <if test="yearSemesterId != null">and b.year_semester_id = #{yearSemesterId}</if>
        <if test="economyCategory != null and economyCategory != ''">
            and d.economy_category = #{economyCategory}
        </if>
        <if test="functionCategories != null and functionCategories.size() > 0">
            and (q.function_category IN
            <foreach collection="functionCategories" item="fc" open="(" separator="," close=")">
                #{fc}
            </foreach>
            or q.function_category is null or q.function_category = '')
        </if>
        <!-- 其他条件... -->
    </where>
</select>
```

#### ✅ 优点：
1. **业务逻辑集中**：业务规则在Java代码中，清晰明了，易于理解
2. **易于测试**：可以编写单元测试验证业务逻辑
3. **易于维护**：规则变更只需要修改Java代码，不需要改SQL
4. **代码复用**：业务逻辑方法可以在多处复用
5. **类型安全**：Java编译器可以检查类型错误
6. **调试友好**：可以在代码中打断点调试
7. **版本控制友好**：代码变更的diff清晰
8. **数据库无关**：不依赖特定数据库特性，便于迁移
9. **易于扩展**：如果将来需要添加更多规则（如权限检查、时间窗口等），容易扩展

#### ❌ 缺点：
1. **性能略差**：可能需要查询更多数据（但在这个场景中，影响很小）
2. **内存占用**：需要加载数据到内存（但通常预算列表不会太大）

---

## 二、最佳实践建议

### 1. **一般原则**

#### ✅ 应该在SQL中实现的逻辑：
- **简单的数据过滤条件**：WHERE条件（如 status = 1, created_at > '2024-01-01'）
- **数据排序**：ORDER BY
- **聚合计算**：COUNT, SUM, AVG等（但复杂业务计算应在代码中）
- **关联查询**：JOIN操作

#### ✅ 应该在Java代码中实现的逻辑：
- **复杂的业务规则**：如"小学和初中可以组合"这种业务规则
- **业务验证**：如权限检查、状态流转规则
- **计算逻辑**：如折扣计算、税费计算
- **条件分支**：复杂的if-else逻辑

### 2. **针对当前场景的建议**

**当前场景分析：**
- 业务规则：小学（1）和初中（2）可以互相看到对方的预算
- 这是一个**明确的业务规则**，可能会变更（如将来添加"幼儿园"）
- 规则相对简单，但在代码中更清晰

**推荐方案：Java代码实现（方案B）**

**理由：**
1. 这是业务规则，不是简单的数据过滤
2. 规则可能会扩展（如添加更多教育阶段组合）
3. 代码可读性和可维护性更重要
4. 性能影响可忽略（预算列表通常不会很大）

---

## 三、性能对比分析

### 场景假设：
- 数据库中有1000条预算记录
- 小学预算：300条
- 初中预算：300条
- 高中预算：400条

### 方案A（SQL中实现）：
```sql
-- 当functionCategory='1'时
SELECT ... WHERE q.function_category IN ('1', '2')
-- 返回：600条记录（小学+初中）
```

### 方案B（代码中实现）：
```java
// 代码先确定需要查询的类别
List<String> categories = Arrays.asList("1", "2");
// SQL查询
SELECT ... WHERE q.function_category IN ('1', '2')
-- 返回：600条记录（小学+初中）
```

**结论：两种方案在数据库层面的查询性能完全相同！**

方案B只是在代码中增加了业务逻辑判断，但最终执行的SQL查询是一样的，所以性能没有差异。

---

## 四、代码质量对比

### 可读性
- **方案A**：需要阅读XML和SQL才能理解业务规则 ❌
- **方案B**：方法名和方法注释清晰表达业务意图 ✅

### 可测试性
- **方案A**：需要启动数据库，编写集成测试 ❌
- **方案B**：可以编写简单的单元测试 ✅
```java
@Test
public void testDetermineTargetFunctionCategories() {
    // 测试小学
    List<String> result = service.determineTargetFunctionCategories("1");
    assertEquals(Arrays.asList("1", "2"), result);
    
    // 测试初中
    result = service.determineTargetFunctionCategories("2");
    assertEquals(Arrays.asList("1", "2"), result);
    
    // 测试高中
    result = service.determineTargetFunctionCategories("3");
    assertEquals(Collections.singletonList("3"), result);
}
```

### 可维护性
- **方案A**：规则变更需要修改SQL，影响数据库层 ❌
- **方案B**：规则变更只需修改Java代码，影响范围小 ✅

---

## 五、实施建议

### 推荐的重构步骤：

1. **在Service层添加业务逻辑方法**
   ```java
   private List<String> determineTargetFunctionCategories(String functionCategory)
   ```

2. **修改Mapper接口，接受List参数**
   ```java
   List<StSemesterBudget> selectAvailableBudgets(
       @Param("yearSemesterId") Long yearSemesterId,
       @Param("economyCategory") String economyCategory,
       @Param("functionCategories") List<String> functionCategories);
   ```

3. **简化SQL，使用IN查询**
   ```xml
   <if test="functionCategories != null and functionCategories.size() > 0">
       and (q.function_category IN
       <foreach collection="functionCategories" item="fc" open="(" separator="," close=")">
           #{fc}
       </foreach>
       or q.function_category is null or q.function_category = '')
   </if>
   ```

4. **编写单元测试**

---

## 六、总结

### 选择建议：

| 场景 | 推荐方案 | 理由 |
|------|---------|------|
| 简单数据过滤 | SQL | 性能好，代码简洁 |
| 复杂业务规则 | Java代码 | 可维护性好，易于测试 |
| 性能敏感场景 | SQL | 减少数据传输 |
| 业务规则可能变更 | Java代码 | 易于扩展和维护 |
| 需要单元测试 | Java代码 | 测试成本低 |

### 对于当前场景：
**强烈推荐使用Java代码实现（方案B）**

原因：
1. ✅ 这是业务规则，不是简单的数据过滤
2. ✅ 规则可能会扩展或变更
3. ✅ 性能影响可忽略
4. ✅ 代码可读性和可维护性更重要
5. ✅ 便于编写单元测试
6. ✅ 符合软件工程最佳实践

