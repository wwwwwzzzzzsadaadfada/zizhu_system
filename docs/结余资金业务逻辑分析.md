# 结余资金业务逻辑分析

## 一、业务场景

### 1. 结余资金的流转过程

1. **历史学期有预算剩余**
   - 历史学期的预算（yearSemesterId < 当前学期ID）可能有剩余资金

2. **结转到当前学期**
   - 历史学期的剩余资金需要先结转到当前学期
   - 结转时会创建一个新的预算记录
   - **新预算的yearSemesterId = 当前学期ID**（重要！）
   - **但关联的指标的quotaSourceType = 2（上学期结转）或 3（历史学期结转）**

3. **在当前学期使用**
   - 结转后的预算可以在当前学期使用
   - 但是在选择预算时，需要能够区分这是"结余资金"还是"本学期下达"

## 二、问题分析

### 当前代码的问题

1. **getAvailableBudgets方法的问题**：
   ```java
   // 5. 在Java代码中过滤当前学期预算（业务规则：排除历史学期预算和结转预算）
   List<StSemesterBudget> currentSemesterBudgets = HistoricalSurplusUtils.filterCurrentSemesterBudgets(
       allBudgets, currentSchoolYear, currentSemesterValue);
   ```
   - 这个方法会过滤掉quotaSourceType为2或3的预算
   - 导致结余资金无法在选择时显示

2. **判断逻辑的问题**：
   - `isCurrentSemesterBudget`方法要求quotaSourceType不能是结转（2或3）
   - 这导致结转后的预算被判断为"不是当前学期预算"
   - 但实际上，这些预算在当前学期是**可用**的，只是来源是"结余"

## 三、正确的业务逻辑

### 预算分类

1. **本学期下达的预算**：
   - yearSemesterId = 当前学期ID
   - quotaSourceType = 1（本学期新下达）
   - **显示**：预算项目名称（无标识）

2. **结余资金（已结转）**：
   - yearSemesterId = 当前学期ID（已结转）
   - quotaSourceType = 2（上学期结转）或 3（历史学期结转）
   - **显示**：预算项目名称（结余）

3. **历史结余（未结转，不可用）**：
   - yearSemesterId < 当前学期ID
   - 这些预算在当前学期**不可用**，需要先结转

### 在预算选择时的逻辑

1. **getAvailableBudgets**应该返回：
   - 所有yearSemesterId = 当前学期ID的预算（包括结余资金）
   - 不需要过滤quotaSourceType

2. **区分显示**：
   - 根据quotaSourceType判断是否为结余资金
   - 如果是结余资金（quotaSourceType = 2 或 3），在预算项目名称后面加上"（结余）"

## 四、解决方案

### 修改点1：getAvailableBudgets方法

**当前逻辑**：
- 查询yearSemesterId = 当前学期ID的预算
- 过滤掉quotaSourceType为2或3的预算（错误！）

**应该改为**：
- 查询yearSemesterId = 当前学期ID的预算
- **不过滤quotaSourceType**，所有在当前学期的预算都应该返回

### 修改点2：toVO方法

**当前逻辑**：
- 根据isHistorical参数判断是否为结余资金
- 但isHistorical是基于学期比较，不能正确识别已结转的结余资金

**应该改为**：
- 根据quotaSourceType判断是否为结余资金
- 如果quotaSourceType = 2 或 3，就是结余资金，设置isHistorical=true，并在预算项目名称后面加上"（结余）"

### 修改点3：isCurrentSemesterBudget方法（如果需要保留）

**当前逻辑**：
- 要求quotaSourceType不能是结转（2或3）

**应该改为**：
- 如果只是判断"是否在当前学期可用"，那么quotaSourceType为2或3的预算也应该返回true
- 或者，这个方法应该只用于特殊场景，不用于getAvailableBudgets的过滤

## 五、实现方案

### 方案1：修改getAvailableBudgets，不使用filterCurrentSemesterBudgets

```java
public List<BudgetVO> getAvailableBudgets(Long currentSemesterId, String economyCategory, String functionCategory) {
    // ... 参数验证和查询当前学期信息 ...
    
    // 查询所有当前学期的预算（包括结余资金）
    List<StSemesterBudget> allBudgets = semesterBudgetMapper.selectAvailableBudgets(
        currentSemesterId, 
        economyCategory, 
        targetFunctionCategories.isEmpty() ? null : targetFunctionCategories
    );
    
    // 直接转换，不需要过滤
    // 在toVO方法中根据quotaSourceType判断是否为结余资金
    return toVOList(allBudgets, false); // 这里传入false，在toVO中重新判断
}
```

### 方案2：修改toVO方法，根据quotaSourceType判断

```java
private BudgetVO toVO(@NonNull StSemesterBudget budget, boolean isHistorical) {
    BudgetVO vo = new BudgetVO();
    BeanUtils.copyProperties(budget, vo);
    
    // 根据quotaSourceType判断是否为结余资金
    boolean isSurplus = QuotaSourceUtils.isCarryOver(budget.getQuotaSourceType());
    vo.setIsHistorical(isSurplus);
    
    // 如果是结余资金，在预算项目名称后面加上（结余）标识
    if (isSurplus && budget.getBudgetProjectName() != null && !budget.getBudgetProjectName().trim().isEmpty()) {
        String budgetProjectName = budget.getBudgetProjectName();
        if (!budgetProjectName.endsWith("（结余）") && !budgetProjectName.endsWith("(结余)")) {
            vo.setBudgetProjectName(budgetProjectName + "（结余）");
        }
    }
    
    return vo;
}
```


