# 锁定金额统计技术方案说明

## 一、当前实现的技术机制

### 1. **SQL聚合查询（Aggregation Query）**
```sql
SELECT COALESCE(SUM(subsidy_amount), 0)
FROM st_student_subsidy_records
WHERE budget_id = #{budgetId}
AND approval_status = 0
```
- **技术点**：使用 `SUM()` 聚合函数实时计算
- **优点**：数据准确，包含所有历史记录
- **缺点**：每次查询都要执行聚合，性能开销较大

### 2. **计算属性模式（Computed Property Pattern）**
```java
// 在Service层动态计算并设置
java.math.BigDecimal actualLocked = stSemesterBudgetMapper.calculateActualLockedAmount(id);
budget.setLockedAmount(actualLocked);
```
- **技术点**：在业务层计算，不依赖存储值
- **优点**：数据一致性高，逻辑清晰
- **缺点**：N+1查询问题（列表查询时）

### 3. **数据修复机制（Data Repair Pattern）**
```java
// 修复单个预算
fixBudgetLockedAmount(budgetId);
// 批量修复所有预算
fixAllBudgetLockedAmounts();
```
- **技术点**：提供手动修复接口
- **优点**：可以修复历史数据不一致问题

---

## 二、可以进一步优化的技术方案

### 方案1：数据库视图（Database View）⭐推荐
**技术机制**：创建数据库视图，自动计算锁定金额

```sql
CREATE VIEW v_budget_with_locked_amount AS
SELECT 
    b.*,
    COALESCE((
        SELECT SUM(r.subsidy_amount)
        FROM st_student_subsidy_records r
        WHERE r.budget_id = b.id
        AND r.approval_status = 0
    ), 0) AS calculated_locked_amount
FROM st_semester_budget b;
```

**优点**：
- 数据库层面自动计算，性能好
- 查询时直接使用视图，代码简洁
- 数据实时准确

**缺点**：
- 需要修改查询SQL使用视图
- 视图可能影响某些复杂查询的性能

---

### 方案2：数据库触发器（Database Trigger）⭐推荐
**技术机制**：在补助记录变更时自动更新预算锁定金额

```sql
-- 创建或更新记录时，增加锁定金额
CREATE TRIGGER trg_subsidy_lock_on_insert
AFTER INSERT ON st_student_subsidy_records
FOR EACH ROW
BEGIN
    IF NEW.approval_status = 0 THEN
        UPDATE st_semester_budget
        SET locked_amount = COALESCE(locked_amount, 0) + NEW.subsidy_amount
        WHERE id = NEW.budget_id;
    END IF;
END;

-- 更新审批状态时，调整锁定金额
CREATE TRIGGER trg_subsidy_lock_on_update
AFTER UPDATE ON st_student_subsidy_records
FOR EACH ROW
BEGIN
    -- 从待审批变为已审批：锁定金额转已使用金额
    IF NEW.approval_status = 1 AND OLD.approval_status = 0 THEN
        UPDATE st_semester_budget
        SET locked_amount = COALESCE(locked_amount, 0) - OLD.subsidy_amount,
            used_amount = COALESCE(used_amount, 0) + OLD.subsidy_amount
        WHERE id = NEW.budget_id;
    END IF;
    
    -- 从待审批变为已驳回：释放锁定金额
    IF NEW.approval_status = 2 AND OLD.approval_status = 0 THEN
        UPDATE st_semester_budget
        SET locked_amount = COALESCE(locked_amount, 0) - OLD.subsidy_amount
        WHERE id = NEW.budget_id;
    END IF;
END;
```

**优点**：
- 数据自动同步，无需手动维护
- 性能好，更新时自动计算
- 数据一致性高

**缺点**：
- 触发器逻辑复杂，调试困难
- 可能影响数据库性能
- 历史数据需要手动修复

---

### 方案3：Redis缓存 + 事件驱动更新 ⭐推荐（高性能场景）
**技术机制**：使用Redis缓存锁定金额，通过事件机制更新

```java
@Service
public class BudgetLockedAmountCacheService {
    
    @Autowired
    private RedisCache redisCache;
    
    private static final String CACHE_KEY_PREFIX = "budget:locked:";
    
    /**
     * 获取锁定金额（优先从缓存）
     */
    public BigDecimal getLockedAmount(Long budgetId) {
        String key = CACHE_KEY_PREFIX + budgetId;
        BigDecimal cached = redisCache.getCacheObject(key);
        if (cached != null) {
            return cached;
        }
        // 缓存未命中，从数据库计算并缓存
        BigDecimal actual = calculateFromDB(budgetId);
        redisCache.setCacheObject(key, actual, 5, TimeUnit.MINUTES);
        return actual;
    }
    
    /**
     * 更新锁定金额（补助记录变更时调用）
     */
    @EventListener
    public void onSubsidyRecordChanged(SubsidyRecordEvent event) {
        String key = CACHE_KEY_PREFIX + event.getBudgetId();
        redisCache.deleteObject(key); // 删除缓存，下次查询时重新计算
    }
}
```

**优点**：
- 查询性能极佳（Redis内存访问）
- 减少数据库压力
- 支持高并发场景

**缺点**：
- 需要维护缓存一致性
- 增加系统复杂度
- 需要处理缓存穿透、击穿问题

---

### 方案4：定时任务同步（Scheduled Task）
**技术机制**：定时任务定期同步锁定金额

```java
@Component
public class BudgetLockedAmountSyncTask {
    
    @Scheduled(cron = "0 */5 * * * ?") // 每5分钟执行一次
    public void syncLockedAmounts() {
        List<StSemesterBudget> budgets = budgetMapper.selectStSemesterBudgetList(new StSemesterBudget());
        for (StSemesterBudget budget : budgets) {
            budgetMapper.fixBudgetLockedAmount(budget.getId());
        }
    }
}
```

**优点**：
- 实现简单
- 定期修复数据不一致

**缺点**：
- 数据不是实时的（有延迟）
- 定时任务可能影响系统性能

---

### 方案5：数据库物化视图（Materialized View）
**技术机制**：MySQL不支持，但PostgreSQL/Oracle支持

```sql
-- PostgreSQL示例
CREATE MATERIALIZED VIEW mv_budget_locked_amount AS
SELECT 
    budget_id,
    SUM(subsidy_amount) AS locked_amount
FROM st_student_subsidy_records
WHERE approval_status = 0
GROUP BY budget_id;

-- 定期刷新
REFRESH MATERIALIZED VIEW mv_budget_locked_amount;
```

**优点**：
- 查询性能好
- 数据预计算

**缺点**：
- MySQL不支持
- 需要定期刷新

---

### 方案6：混合方案（当前实现 + 优化）⭐最佳实践
**技术机制**：结合多种技术

1. **查询时动态计算**（当前实现）- 保证准确性
2. **Redis缓存** - 提升性能
3. **定时任务修复** - 修复历史数据
4. **数据库触发器** - 自动维护（可选）

```java
@Service
public class OptimizedBudgetService {
    
    @Autowired
    private RedisCache redisCache;
    
    public StSemesterBudget selectStSemesterBudgetById(Long id) {
        StSemesterBudget budget = mapper.selectStSemesterBudgetById(id);
        
        // 1. 先查缓存
        String cacheKey = "budget:locked:" + id;
        BigDecimal cached = redisCache.getCacheObject(cacheKey);
        
        if (cached != null) {
            budget.setLockedAmount(cached);
        } else {
            // 2. 缓存未命中，从数据库计算
            BigDecimal actual = mapper.calculateActualLockedAmount(id);
            budget.setLockedAmount(actual);
            // 3. 写入缓存（5分钟过期）
            redisCache.setCacheObject(cacheKey, actual, 5, TimeUnit.MINUTES);
        }
        
        return budget;
    }
    
    // 补助记录变更时，清除缓存
    @EventListener
    public void onSubsidyChanged(SubsidyRecordEvent event) {
        redisCache.deleteObject("budget:locked:" + event.getBudgetId());
    }
}
```

---

## 三、技术选型建议

### 场景1：数据准确性优先（当前场景）
✅ **当前方案**：动态计算 + 数据修复
- 适合：数据准确性要求高，查询频率不高

### 场景2：性能优先
✅ **推荐方案**：Redis缓存 + 事件驱动
- 适合：高并发查询，数据可以短暂延迟

### 场景3：自动化维护
✅ **推荐方案**：数据库触发器
- 适合：希望数据库层面自动维护，减少应用层代码

### 场景4：最佳实践（推荐）
✅ **混合方案**：
- 查询时动态计算（保证准确性）
- Redis缓存（提升性能）
- 定时任务修复（修复历史数据）
- 数据库触发器（自动维护，可选）

---

## 四、性能对比

| 方案 | 查询性能 | 数据准确性 | 实现复杂度 | 适用场景 |
|------|---------|-----------|-----------|---------|
| 动态计算（当前） | ⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐ | 准确性优先 |
| 数据库视图 | ⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ | 中等查询量 |
| 数据库触发器 | ⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐ | 自动化维护 |
| Redis缓存 | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐ | 高并发场景 |
| 定时任务 | ⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐ | 数据可延迟 |
| 混合方案 | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ | 最佳实践 |

---

## 五、实施建议

1. **短期**：保持当前动态计算方案，确保数据准确
2. **中期**：添加Redis缓存，提升查询性能
3. **长期**：考虑数据库触发器，实现自动化维护

