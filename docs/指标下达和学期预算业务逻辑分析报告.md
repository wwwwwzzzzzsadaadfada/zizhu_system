# 指标下达和学期预算业务逻辑分析报告

## 一、业务逻辑概述

### 1.1 指标下达流程
1. 创建指标（`st_subsidy_quota`）和指标明细（`st_subsidy_quota_detail`）
2. 将指标明细金额分配到学期预算（`st_semester_budget`）
3. 更新指标明细和指标的已分配金额（`allocated_amount`）

### 1.2 学期预算使用流程
1. 录入补助时锁定预算金额（`locked_amount`）
2. 审批通过后，锁定金额转为已使用金额（`used_amount`）
3. 审批驳回或退回时，释放锁定金额或已使用金额

## 二、发现的问题和风险

### 🔴 严重问题

#### 1. **删除预算时的锁定金额检查不准确**
**位置**：`StSemesterBudgetServiceImpl.deleteStSemesterBudgetById()`

**问题描述**：
```java
if (safe(originalBudget.getUsedAmount()).compareTo(ZERO) > 0 || 
    safe(originalBudget.getLockedAmount()).compareTo(ZERO) > 0) {
    throw new ServiceException("预算已被使用或锁定，无法删除");
}
```

**问题**：
- 使用 `originalBudget.getLockedAmount()` 是数据库存储值，可能不准确
- 锁定金额应该动态计算（从未审批记录汇总），而不是使用存储值
- 可能导致有未审批记录时仍能删除预算，造成数据不一致

**风险等级**：🔴 高

**修复建议**：
```java
// 动态计算实际锁定金额
BigDecimal actualLocked = stSemesterBudgetMapper.calculateActualLockedAmount(id);
if (safe(originalBudget.getUsedAmount()).compareTo(ZERO) > 0 || 
    (actualLocked != null && actualLocked.compareTo(ZERO) > 0)) {
    throw new ServiceException("预算已被使用或锁定，无法删除");
}
```

---

#### 2. **指标分配时缺少并发控制**
**位置**：`StSubsidyQuotaServiceImpl.allocateQuota()`

**问题描述**：
- 指标分配涉及多个步骤：
  1. 检查指标明细可用金额
  2. 创建学期预算
  3. 更新指标明细已分配金额
  4. 更新指标已分配金额
- 整个过程没有使用锁机制，存在并发竞态条件

**风险场景**：
- 用户A和用户B同时分配同一指标明细
- 两者都通过可用金额检查
- 导致分配金额超过指标总额

**风险等级**：🔴 高

**修复建议**：
```java
// 方案1：使用数据库悲观锁
@Transactional(isolation = Isolation.SERIALIZABLE)
public Long allocateQuota(QuotaAllocationRequest request) {
    // 使用 FOR UPDATE 锁定指标明细
    StSubsidyQuotaDetail detail = stSubsidyQuotaDetailMapper
        .selectStSubsidyQuotaDetailByIdForUpdate(request.getQuotaDetailId());
    // ... 后续逻辑
}

// 方案2：使用分布式锁
String lockKey = "quota_detail:" + request.getQuotaDetailId();
String lockValue = redisDistributedLock.tryLock(lockKey, 30);
try {
    // ... 分配逻辑
} finally {
    redisDistributedLock.releaseLock(lockKey, lockValue);
}
```

---

#### 3. **指标已分配金额更新缺少事务保护**
**位置**：`StSemesterBudgetServiceImpl.adjustQuotaAllocation()`

**问题描述**：
```java
private void adjustQuotaAllocation(Long quotaId, Long quotaDetailId, BigDecimal amountChange) {
    if (quotaDetailId != null) {
        stSubsidyQuotaDetailMapper.updateAllocatedAmount(quotaDetailId, amountChange);
    }
    if (quotaId != null) {
        stSubsidyQuotaMapper.updateAllocatedAmount(quotaId, amountChange);
    }
}
```

**问题**：
- 两个更新操作没有原子性保证
- 如果第二个更新失败，第一个已更新，导致数据不一致
- SQL更新使用 `COALESCE(allocated_amount, 0) + #{amount}`，如果amount为负数且allocated_amount不足，可能导致负数

**风险等级**：🟡 中

**修复建议**：
```xml
<!-- 在SQL中添加WHERE条件防止负数 -->
<update id="updateAllocatedAmount">
    update st_subsidy_quota_detail
    set allocated_amount = COALESCE(allocated_amount, 0) + #{amount}
    where id = #{detailId}
    and (COALESCE(allocated_amount, 0) + #{amount}) >= 0
</update>
```

---

### 🟡 中等问题

#### 4. **预算修改时指标容量验证的竞态条件**
**位置**：`StSemesterBudgetServiceImpl.updateStSemesterBudget()`

**问题描述**：
```java
validateQuotaCapacity(stSemesterBudget, newAmount, restoreAmount);
int result = stSemesterBudgetMapper.updateStSemesterBudget(stSemesterBudget);
adjustQuotaAllocation(...);
```

**问题**：
- 验证和更新之间存在时间窗口
- 在验证通过后、更新前，其他事务可能已分配指标，导致超分配

**风险等级**：🟡 中

**修复建议**：
- 使用悲观锁在验证时锁定指标明细
- 或使用乐观锁版本号机制

---

#### 5. **指标明细删除时缺少预算关联检查**
**位置**：`StSubsidyQuotaServiceImpl.deleteStSubsidyQuotaById()`

**问题描述**：
```java
if (safe(detail.getAllocatedAmount()).compareTo(ZERO) > 0) {
    throw new ServiceException("存在已分配金额的明细，禁止删除指标");
}
```

**问题**：
- 只检查了 `allocatedAmount` 字段
- 应该直接查询是否有关联的预算记录，更准确

**风险等级**：🟡 中

**修复建议**：
```java
// 检查是否有关联的预算记录
Long budgetCount = stSemesterBudgetMapper.countByQuotaDetailId(detail.getId());
if (budgetCount > 0) {
    throw new ServiceException("指标明细已关联预算，禁止删除");
}
```

---

#### 6. **锁定金额的动态计算与存储值不一致**
**位置**：多处使用 `locked_amount` 字段

**问题描述**：
- 系统已实现动态计算锁定金额（从补助记录汇总）
- 但某些地方仍使用数据库存储的 `locked_amount` 字段
- 可能导致数据不一致

**风险等级**：🟡 中

**修复建议**：
- 统一使用动态计算，移除对存储值的依赖
- 或定期同步存储值与实际值

---

### 🟢 轻微问题

#### 7. **指标分配时缺少预算状态检查**
**位置**：`StSubsidyQuotaServiceImpl.allocateQuota()`

**问题描述**：
- 创建预算时直接设置 `status = 1`（启用）
- 没有检查目标学期是否已存在相同指标的预算

**风险等级**：🟢 低

**修复建议**：
- 检查是否已存在相同 `quota_detail_id` 和 `year_semester_id` 的预算
- 如果存在，可以选择合并或提示

---

#### 8. **批量删除预算时缺少事务回滚保护**
**位置**：`StSemesterBudgetServiceImpl.deleteStSemesterBudgetByIds()`

**问题描述**：
```java
for (Long id : ids) {
    count += deleteStSemesterBudgetById(id);
}
```

**问题**：
- 如果中间某个删除失败，已删除的不会回滚
- 应该使用批量操作或确保原子性

**风险等级**：🟢 低

---

## 三、数据一致性风险

### 3.1 指标已分配金额不一致
**风险**：指标明细的 `allocated_amount` 与实际预算总额不一致

**原因**：
- 并发更新导致
- 异常回滚不完整
- 手动修改数据库

**解决方案**：
- 已有 `fixAllocatedAmount()` 修复方法
- 建议定期执行修复任务

### 3.2 预算锁定金额不一致
**风险**：预算的 `locked_amount` 与实际未审批记录总额不一致

**原因**：
- 动态计算与存储值不同步

**解决方案**：
- 已实现动态计算
- 建议移除对存储值的依赖，统一使用动态计算

---

## 四、性能优化建议

### 4.1 批量操作优化
- 指标分配时，如果批量分配多个明细，应该批量更新已分配金额
- 避免循环单次更新

### 4.2 查询优化
- 指标明细可用金额计算可以添加索引
- 预算列表查询时，锁定金额的动态计算可能影响性能，考虑缓存

---

## 五、已修复的问题

### ✅ 已修复（2025-01-XX）

#### 1. **删除预算时的锁定金额检查**
- **修复**：使用动态计算的锁定金额替代存储值
- **位置**：`StSemesterBudgetServiceImpl.deleteStSemesterBudgetById()`
- **状态**：✅ 已修复

#### 2. **指标分配时的并发控制**
- **修复**：使用悲观锁（`FOR UPDATE`）查询指标明细
- **位置**：`StSubsidyQuotaServiceImpl.allocateQuota()`
- **状态**：✅ 已修复

#### 3. **指标已分配金额更新防止负数**
- **修复**：在SQL的WHERE条件中添加检查，防止负数
- **位置**：`StSubsidyQuotaDetailMapper.xml` 和 `StSubsidyQuotaMapper.xml`
- **状态**：✅ 已修复

#### 4. **指标分配时的错误处理**
- **修复**：添加更新结果检查，失败时抛出异常
- **位置**：`StSubsidyQuotaServiceImpl.allocateQuota()`
- **状态**：✅ 已修复

#### 5. **预算修改时的指标容量验证**
- **修复**：使用悲观锁查询指标明细
- **位置**：`StSemesterBudgetServiceImpl.validateQuotaCapacity()`
- **状态**：✅ 已修复

#### 6. **指标明细删除时检查预算关联**
- **修复**：直接查询预算表统计关联数量，替代检查allocatedAmount字段
- **位置**：`StSubsidyQuotaServiceImpl.deleteStSubsidyQuotaById()`
- **新增方法**：`StSemesterBudgetMapper.countByQuotaDetailId()`
- **状态**：✅ 已修复

#### 7. **指标分配时检查重复预算**
- **修复**：在分配前检查是否已存在相同指标明细和学期的预算
- **位置**：`StSubsidyQuotaServiceImpl.allocateQuota()`
- **新增方法**：`StSemesterBudgetMapper.countByQuotaDetailAndSemester()`
- **状态**：✅ 已修复

#### 8. **批量删除预算的原子性保证**
- **修复**：先统一验证所有预算是否可以删除，再批量删除，确保原子性
- **位置**：`StSemesterBudgetServiceImpl.deleteStSemesterBudgetByIds()`
- **状态**：✅ 已修复

---

## 六、改进方案优先级

### 高优先级（已修复）
1. ✅ 删除预算时使用动态计算的锁定金额
2. ✅ 指标分配时添加并发控制（悲观锁）
3. ✅ 指标已分配金额更新添加WHERE条件防止负数
4. ✅ 指标分配时的错误处理
5. ✅ 预算修改时的指标容量验证

### 中优先级（已修复）
6. ✅ 指标明细删除时检查预算关联（直接查询预算表，更准确）
7. 统一锁定金额的计算方式（移除对存储值的依赖）- 已通过动态计算实现，存储值仅作参考

### 低优先级（已修复）
8. ✅ 指标分配时检查重复预算（相同quota_detail_id和year_semester_id）
9. ✅ 批量删除预算的原子性保证（先统一验证，再批量删除）

### 低优先级（优化改进）
10. 性能优化（批量操作、索引、缓存）

---

## 七、测试建议

### 6.1 并发测试
- 多用户同时分配同一指标明细
- 多用户同时修改同一预算
- 多用户同时删除预算

### 6.2 数据一致性测试
- 异常回滚后的数据一致性
- 修复方法 `fixAllocatedAmount()` 的正确性
- 锁定金额动态计算的准确性

### 6.3 边界条件测试
- 分配金额等于可用金额
- 分配金额为0或负数
- 删除有关联数据的指标/预算

